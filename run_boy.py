import sys
import pygame

from settings_run_boy import Settings
from hero_run_boy import Hero
from enemy_run_boy import Enemy
from button import Button
from game_stats import GameStats
from scoreboard_run_boy import ScoreBoard

"""Zadania"""
# dodaj kolizje obcych ze soba
# wiecej opcji w grze np.lvl


class RunBoy:
    """Main class designe for resource menagmnet and operation in the game"""

    def __init__(self):
        """Initialization of the game and create resource for the game"""

        pygame.init()
        self.setting = Settings()
        self.enemys = pygame.sprite.Group()

        # Creating screen
        self.screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
        self.setting.screen_width = self.screen.get_rect().width
        self.setting.screen_height = self.screen.get_rect().height
        pygame.display.set_caption("Run Boy")

        self.stats = GameStats(self)
        self.score_board = ScoreBoard(self)
        self.hero = Hero(self)

        # Button to starting game
        self.play_button = Button(
            self,
            "Play",
            (self.setting.screen_width / 2) - 100,
            (self.setting.screen_height / 2) - 100,
        )

        # Button for exit game
        self.exit_button = Button(
            self,
            "Exit",
            (self.setting.screen_width / 2) - 100,
            (self.setting.screen_height / 2) + 100,
        )

    def run_game(self):
        """Main loop for game"""
        self.x = pygame.time.get_ticks()
        self.y = pygame.time.get_ticks()

        while True:

            self._check_events()
            if self.stats.game_active:

                # Methods using when game is active
                self._upgrade_level()
                self._check_time()
                self.hero.update()
                self._update_enemy()
                self._end_game()
            else:

                # Methods using when game is unactive
                self.z = (pygame.time.get_ticks() - self.y) / 1000
                self.score_board.prep_score()
                self.stats.reset_stats()

                # Show the mouse cursor
                self._game_on()

            # Methods using all time
            self._update_screen()
            self._game_on()

    def _check_events(self):
        """Reaction to events generated by mouse and keyboard"""

        # Wait to click/move  mouse or push button
        for event in pygame.event.get():

            if event.type == pygame.KEYDOWN:
                self._check_keydown_events(event)
            elif event.type == pygame.KEYUP:
                self._check_keyup_events(event)
            elif event.type == pygame.MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                self._check_click_button(mouse_pos)

    def _update_screen(self):
        """Update scree and jump to next screen"""

        self.score_board.prep_score()
        self.screen.fill(self.setting.background_color)
        self.hero.blitme()
        self.enemys.draw(self.screen)
        self.score_board.show_score()

        # Shoving buttons when game is unactive
        if not self.stats.game_active:
            self.play_button.draw_button()
            self.exit_button.draw_button()

        pygame.display.flip()

    def _check_keydown_events(self, event):
        """Reaction to down a kay"""

        if event.key == pygame.K_ESCAPE:
            self.stats.game_active = False
            self.setting.game_on = False
        elif event.key == pygame.K_RIGHT:
            self.hero.moving_right = True
        elif event.key == pygame.K_LEFT:
            self.hero.moving_left = True
        elif event.key == pygame.K_DOWN:
            self.hero.moving_down = True
        elif event.key == pygame.K_UP:
            self.hero.moving_up = True

    def _check_keyup_events(self, event):
        """Reaction to key losing"""

        if event.key == pygame.K_RIGHT:
            self.hero.moving_right = False
        elif event.key == pygame.K_LEFT:
            self.hero.moving_left = False
        elif event.key == pygame.K_DOWN:
            self.hero.moving_down = False
        elif event.key == pygame.K_UP:
            self.hero.moving_up = False

    def _check_click_button(self, mouse_pos):
        """Reaction to click a mouse"""

        if self.play_button.rect.collidepoint(mouse_pos):
            self._create_enemy()
            self.stats.game_active = True
        elif self.exit_button.rect.collidepoint(mouse_pos):
            sys.exit()

    def _game_on(self):
        """Hiding mouse"""

        if self.stats.game_active == True:
            pygame.mouse.set_visible(False)

        elif self.stats.game_active == False:
            pygame.mouse.set_visible(True)

    def _end_game(self):
        """If you touch enemy i will end game"""

        if pygame.sprite.spritecollideany(self.hero, self.enemys):
            self._hero_hit()

    def _hero_hit(self):
        """Reaction to touch enemy"""

        self.stats.live_left -= 1

        if self.stats.live_left == 0:
            self.stats.game_active = False

    def _create_enemy(self):
        """Creating enemys"""

        # Create enemy
        enemy = Enemy(self)
        self.enemys.add(enemy)

    def _update_enemy(self):
        """Control enemys"""

        self.enemys.update()

    def _upgrade_level(self):
        """Changing level"""

        self.setting.level += 1

        if self.setting.level % 2000 == 0:
            self._create_enemy()
            self.setting.enemy_speed *= 1.4

    def _check_time(self):
        """When gam is active this method counts time"""
        self.stats.time = ((pygame.time.get_ticks() - self.x) / 1000) - self.z


if __name__ == "__main__":
    """Creating a copy of the game and lauching it"""
    run_boy = RunBoy()
    run_boy.run_game()
